// supabase/functions/channel-autoposter/index.ts
// 
// –ê–≤—Ç–æ–ø–æ—Å—Ç–∏–Ω–≥ –∑–∞–∫–∞–∑–æ–≤ –≤ Telegram-–∫–∞–Ω–∞–ª
// - –û–¥–∏–Ω–æ—á–Ω—ã–µ –ø–æ—Å—Ç—ã –ø—Ä–∏ –æ–¥–æ–±—Ä–µ–Ω–∏–∏ –∑–∞–∫–∞–∑–∞
// - –ö–æ–º–ø–∞–∫—Ç–Ω—ã–π –¥–∞–π–¥–∂–µ—Å—Ç –ø–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é
// - –í—ã–±–æ—Ä–æ—á–Ω—ã–π –¥–∞–π–¥–∂–µ—Å—Ç –ø–æ ID
// - –û—Ç–ª–æ–∂–µ–Ω–Ω–∞—è –ø—É–±–ª–∏–∫–∞—Ü–∏—è (scheduled posts)
//
// –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è (Supabase Dashboard ‚Üí Edge Functions ‚Üí Secrets):
// - BOT_TOKEN: —Ç–æ–∫–µ–Ω –±–æ—Ç–∞ –æ—Ç @BotFather
// - CHANNEL_ID: ID –∏–ª–∏ username –∫–∞–Ω–∞–ª–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä: @hey_freelancer)
// - WEBAPP_URL: URL –≤–∞—à–µ–≥–æ Mini App

import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from "https://esm.sh/@supabase/supabase-js@2"

// ============================================
// –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø
// ============================================

const BOT_TOKEN = Deno.env.get('BOT_TOKEN')!
const CHANNEL_ID = Deno.env.get('CHANNEL_ID') || '@hey_freelancer'
const WEBAPP_URL = Deno.env.get('WEBAPP_URL') || 't.me/hey_birazhabot/start'
const SUPABASE_URL = Deno.env.get('SUPABASE_URL')!
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)

// ============================================
// –ö–ê–¢–ï–ì–û–†–ò–ò –ò –≠–ú–û–î–ó–ò
// ============================================

const CATEGORY_CONFIG: Record<string, { emoji: string; label: string; hashtag: string }> = {
  'DEVELOPMENT': { emoji: 'üíª', label: '–†–∞–∑—Ä–∞–±–æ—Ç–∫–∞', hashtag: '#—Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞' },
  'DESIGN': { emoji: 'üé®', label: '–î–∏–∑–∞–π–Ω', hashtag: '#–¥–∏–∑–∞–π–Ω' },
  'MARKETING': { emoji: 'üìà', label: '–ú–∞—Ä–∫–µ—Ç–∏–Ω–≥', hashtag: '#–º–∞—Ä–∫–µ—Ç–∏–Ω–≥' },
  'COPYWRITING': { emoji: '‚úçÔ∏è', label: '–¢–µ–∫—Å—Ç—ã', hashtag: '#–∫–æ–ø–∏—Ä–∞–π—Ç–∏–Ω–≥' },
  'OTHER': { emoji: 'üì¶', label: '–†–∞–∑–Ω–æ–µ', hashtag: '#—Ä–∞–∑–Ω–æ–µ' },
}

// ============================================
// –¢–ò–ü–´
// ============================================

interface Job {
  id: string | number;
  title: string;
  description: string;
  budget: string;
  category: string;
  is_pinned?: boolean;
  is_highlighted?: boolean;
  is_urgent?: boolean;
  author_id?: number;
  created_at?: string;
  scheduled_at?: string;
}

interface TelegramResponse {
  ok: boolean;
  result?: any;
  description?: string;
}

// ============================================
// –§–û–†–ú–ê–¢–ò–†–û–í–ê–ù–ò–ï - –û–î–ò–ù–û–ß–ù–´–ô –ü–û–°–¢
// ============================================

function formatSingleJobPost(job: Job): string {
  const config = CATEGORY_CONFIG[job.category] || CATEGORY_CONFIG['OTHER']
  
  const badges: string[] = []
  if (job.is_urgent) badges.push('üî• –°–†–û–ß–ù–û')
  if (job.is_pinned) badges.push('üìå –¢–û–ü')
  if (job.is_highlighted) badges.push('‚≠êÔ∏è VIP')
  
  const badgeLine = badges.length > 0 ? `${badges.join(' ‚Ä¢ ')}\n\n` : ''
  
  let description = job.description
  if (description.length > 500) {
    description = description.slice(0, 497) + '...'
  }
  
  const escapeHtml = (text: string) => {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
  }
  
  return `${badgeLine}${config.emoji} <b>${escapeHtml(job.title)}</b>

${escapeHtml(description)}

üí∞ <b>–ë—é–¥–∂–µ—Ç:</b> ${escapeHtml(job.budget)}
üìÅ <b>–ö–∞—Ç–µ–≥–æ—Ä–∏—è:</b> ${config.label}

${config.hashtag} #—Ñ—Ä–∏–ª–∞–Ω—Å #—É–¥–∞–ª—ë–Ω–∫–∞`
}

// ============================================
// –§–û–†–ú–ê–¢–ò–†–û–í–ê–ù–ò–ï - –ö–û–ú–ü–ê–ö–¢–ù–´–ô –î–ê–ô–î–ñ–ï–°–¢
// ============================================

function formatCompactDigest(jobs: Job[]): string {
  const escapeHtml = (text: string) => {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
  }
  
  const today = new Date()
  const dateStr = today.toLocaleDateString('ru-RU', { 
    day: 'numeric', 
    month: 'long' 
  })
  
  // –ó–∞–≥–æ–ª–æ–≤–æ–∫
  let post = `üìã <b>–°–≤–µ–∂–∏–µ –∑–∞–∫–∞–∑—ã</b> ‚Ä¢ ${dateStr}\n\n`
  
  // –ö–æ–º–ø–∞–∫—Ç–Ω—ã–π —Å–ø–∏—Å–æ–∫ –∑–∞–∫–∞–∑–æ–≤
  jobs.forEach((job, index) => {
    const config = CATEGORY_CONFIG[job.category] || CATEGORY_CONFIG['OTHER']
    
    // –ë–µ–π–¥–∂–∏ –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É
    const badges: string[] = []
    if (job.is_urgent) badges.push('üî•')
    if (job.is_pinned) badges.push('üìå')
    if (job.is_highlighted) badges.push('‚≠êÔ∏è')
    const badgeStr = badges.length > 0 ? ` ${badges.join('')}` : ''
    
    // –û–±—Ä–µ–∑–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–æ 50 —Å–∏–º–≤–æ–ª–æ–≤
    let title = job.title
    if (title.length > 50) {
      title = title.slice(0, 47) + '...'
    }
    
    // –§–æ—Ä–º–∞—Ç: 1. üíª –ù–∞–∑–≤–∞–Ω–∏–µ ‚Äî 50 000 ‚ÇΩ [‚Üí]
    post += `<b>${index + 1}.</b> ${config.emoji} ${escapeHtml(title)}${badgeStr}\n`
    post += `     üí∞ ${escapeHtml(job.budget)} ¬∑ <a href="${WEBAPP_URL}?startapp=job_${job.id}">–û—Ç–∫–ª–∏–∫–Ω—É—Ç—å—Å—è</a>\n\n`
  })
  
  // –§—É—Ç–µ—Ä
  post += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`
  post += `üì± <a href="${WEBAPP_URL}">–í—Å–µ –∑–∞–∫–∞–∑—ã –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏</a>\n\n`
  post += `#—Ñ—Ä–∏–ª–∞–Ω—Å #—Ä–∞–±–æ—Ç–∞ #—É–¥–∞–ª—ë–Ω–∫–∞`
  
  return post
}

// ============================================
// –§–û–†–ú–ê–¢–ò–†–û–í–ê–ù–ò–ï - –ö–†–ê–°–ò–í–´–ô –î–ê–ô–î–ñ–ï–°–¢
// ============================================

function formatPrettyDigest(jobs: Job[]): string {
  const escapeHtml = (text: string) => {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
  }
  
  const today = new Date()
  const dateStr = today.toLocaleDateString('ru-RU', { 
    day: 'numeric', 
    month: 'long' 
  })
  
  // –°—á–∏—Ç–∞–µ–º –æ–±—â–∏–π –±—é–¥–∂–µ—Ç
  let totalBudget = 0
  jobs.forEach(job => {
    const match = job.budget.replace(/\s/g, '').match(/(\d+)/)
    if (match) totalBudget += parseInt(match[1])
  })
  
  // –ó–∞–≥–æ–ª–æ–≤–æ–∫
  let post = `üî• <b>–ì–û–†–Ø–ß–ò–ï –ó–ê–ö–ê–ó–´</b>\n`
  post += `üìÖ ${dateStr}\n\n`
  
  // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
  post += `üìä <b>${jobs.length}</b> –∑–∞–∫–∞–∑–æ–≤ ¬∑ <b>${totalBudget.toLocaleString('ru-RU')} ‚ÇΩ</b> –±—é–¥–∂–µ—Ç\n\n`
  post += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`
  
  // –ö–∞—Ä—Ç–æ—á–∫–∏ –∑–∞–∫–∞–∑–æ–≤
  jobs.forEach((job) => {
    const config = CATEGORY_CONFIG[job.category] || CATEGORY_CONFIG['OTHER']
    
    // –ë–µ–π–¥–∂–∏
    const badges: string[] = []
    if (job.is_urgent) badges.push('üî•')
    if (job.is_pinned) badges.push('üìå')
    if (job.is_highlighted) badges.push('‚≠ê')
    const badgeStr = badges.length > 0 ? ` ${badges.join('')}` : ''
    
    // –û–±—Ä–µ–∑–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ
    let title = job.title
    if (title.length > 40) {
      title = title.slice(0, 37) + '...'
    }
    
    // –ö–∞—Ä—Ç–æ—á–∫–∞
    post += `${config.emoji} <b>${escapeHtml(title)}</b>${badgeStr}\n`
    post += `‚îî üí∞ ${escapeHtml(job.budget)} ¬∑ <a href="${WEBAPP_URL}?startapp=job_${job.id}">–û—Ç–∫–ª–∏–∫–Ω—É—Ç—å—Å—è ‚Üí</a>\n\n`
  })
  
  // –§—É—Ç–µ—Ä
  post += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`
  post += `üëâ <a href="${WEBAPP_URL}">–°–º–æ—Ç—Ä–µ—Ç—å –≤—Å–µ –∑–∞–∫–∞–∑—ã</a>\n\n`
  post += `#—Ñ—Ä–∏–ª–∞–Ω—Å #—Ä–∞–±–æ—Ç–∞ #–∑–∞–∫–∞–∑—ã`
  
  return post
}

// ============================================
// –§–û–†–ú–ê–¢–ò–†–û–í–ê–ù–ò–ï - –ú–ò–ù–ò–ú–ê–õ–ò–°–¢–ò–ß–ù–´–ô –î–ê–ô–î–ñ–ï–°–¢
// ============================================

function formatMinimalDigest(jobs: Job[]): string {
  const escapeHtml = (text: string) => {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
  }
  
  let post = `üìã <b>–ù–æ–≤—ã–µ –∑–∞–∫–∞–∑—ã:</b>\n\n`
  
  jobs.forEach((job) => {
    const config = CATEGORY_CONFIG[job.category] || CATEGORY_CONFIG['OTHER']
    
    let title = job.title
    if (title.length > 35) {
      title = title.slice(0, 32) + '...'
    }
    
    // –û–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞ –Ω–∞ –∑–∞–∫–∞–∑
    post += `${config.emoji} <a href="${WEBAPP_URL}?startapp=job_${job.id}">${escapeHtml(title)}</a> ‚Äî ${escapeHtml(job.budget)}\n`
  })
  
  post += `\nüì± <a href="${WEBAPP_URL}">–û—Ç–∫—Ä—ã—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ</a>`
  
  return post
}

// ============================================
// –û–¢–ü–†–ê–í–ö–ê –í TELEGRAM
// ============================================

async function sendToChannel(text: string, inlineKeyboard?: any): Promise<TelegramResponse> {
  const body: any = {
    chat_id: CHANNEL_ID,
    text: text,
    parse_mode: 'HTML',
    disable_web_page_preview: true
  }
  
  if (inlineKeyboard) {
    body.reply_markup = inlineKeyboard
  }
  
  const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  })
  
  return response.json()
}

async function sendSingleJob(job: Job): Promise<TelegramResponse> {
  const text = formatSingleJobPost(job)
  
  const inlineKeyboard = {
    inline_keyboard: [
      [{ text: 'üìù –û—Ç–∫–ª–∏–∫–Ω—É—Ç—å—Å—è', url: `${WEBAPP_URL}?startapp=job_${job.id}` }],
      [{ text: 'üìã –í—Å–µ –∑–∞–∫–∞–∑—ã', url: WEBAPP_URL }]
    ]
  }
  
  return sendToChannel(text, inlineKeyboard)
}

async function sendDigest(jobs: Job[], format: 'compact' | 'pretty' | 'minimal' = 'pretty'): Promise<TelegramResponse> {
  let text: string
  
  switch (format) {
    case 'compact':
      text = formatCompactDigest(jobs)
      break
    case 'minimal':
      text = formatMinimalDigest(jobs)
      break
    case 'pretty':
    default:
      text = formatPrettyDigest(jobs)
  }
  
  const inlineKeyboard = {
    inline_keyboard: [
      [{ text: 'üì± –û—Ç–∫—Ä—ã—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ', url: WEBAPP_URL }]
    ]
  }
  
  return sendToChannel(text, inlineKeyboard)
}

// ============================================
// –õ–û–ì–ò–†–û–í–ê–ù–ò–ï
// ============================================

async function logPost(jobId: string | number | null, success: boolean, telegramResponse: any) {
  try {
    await supabase.from('channel_posts').insert({
      job_id: jobId,
      channel_id: CHANNEL_ID,
      success: success,
      telegram_message_id: telegramResponse?.result?.message_id,
      error: success ? null : telegramResponse?.description,
      posted_at: new Date().toISOString()
    })
  } catch (e) {
    console.error('Failed to log post:', e)
  }
}

// ============================================
// –ì–õ–ê–í–ù–´–ô –û–ë–†–ê–ë–û–¢–ß–ò–ö
// ============================================

serve(async (req) => {
  try {
    const payload = await req.json()
    const { type, table, record, old_record, action } = payload
    
    console.log(`Received: action=${action}, type=${type}, table=${table}`)
    
    // ========================================
    // 1. –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ò–ô –ü–û–°–¢ –ü–†–ò –û–î–û–ë–†–ï–ù–ò–ò
    // ========================================
    if (table === 'jobs') {
      
      if (type === 'INSERT' && record.status === 'OPEN') {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º scheduled_at ‚Äî –µ—Å–ª–∏ –≤—Ä–µ–º—è –Ω–µ –ø—Ä–∏—à–ª–æ, –Ω–µ –ø—É–±–ª–∏–∫—É–µ–º
        if (record.scheduled_at && new Date(record.scheduled_at) > new Date()) {
          console.log(`Job ${record.id} is scheduled for ${record.scheduled_at}, skipping...`)
          return new Response(JSON.stringify({ success: true, message: 'Scheduled for later' }), {
            headers: { 'Content-Type': 'application/json' }
          })
        }
        
        console.log(`New OPEN job: ${record.id}`)
        const result = await sendSingleJob(record)
        await logPost(record.id, result.ok, result)
        return new Response(JSON.stringify({ success: result.ok }), {
          headers: { 'Content-Type': 'application/json' }
        })
      }
      
      if (type === 'UPDATE' && old_record?.status === 'PENDING' && record.status === 'OPEN') {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º scheduled_at ‚Äî –µ—Å–ª–∏ –≤—Ä–µ–º—è –Ω–µ –ø—Ä–∏—à–ª–æ, –Ω–µ –ø—É–±–ª–∏–∫—É–µ–º
        if (record.scheduled_at && new Date(record.scheduled_at) > new Date()) {
          console.log(`Job ${record.id} is scheduled for ${record.scheduled_at}, skipping...`)
          return new Response(JSON.stringify({ success: true, message: 'Scheduled for later' }), {
            headers: { 'Content-Type': 'application/json' }
          })
        }
        
        console.log(`Job approved: ${record.id}`)
        const result = await sendSingleJob(record)
        await logPost(record.id, result.ok, result)
        return new Response(JSON.stringify({ success: result.ok }), {
          headers: { 'Content-Type': 'application/json' }
        })
      }
    }
    
    // ========================================
    // 2. –†–£–ß–ù–û–ô –ü–û–°–¢ –û–î–ù–û–ì–û –ó–ê–ö–ê–ó–ê
    // ========================================
    if (action === 'post_job' && payload.job_id) {
      const { data: job, error } = await supabase
        .from('jobs')
        .select('*')
        .eq('id', payload.job_id)
        .single()
      
      if (error || !job) {
        return new Response(JSON.stringify({ error: 'Job not found' }), { status: 404 })
      }
      
      const result = await sendSingleJob(job)
      await logPost(job.id, result.ok, result)
      
      return new Response(JSON.stringify({ success: result.ok, result }), {
        headers: { 'Content-Type': 'application/json' }
      })
    }
    
    // ========================================
    // 3. –î–ê–ô–î–ñ–ï–°–¢ (–ø–æ—Å–ª–µ–¥–Ω–∏–µ N –∑–∞–∫–∞–∑–æ–≤)
    // ========================================
    if (action === 'post_digest') {
      const limit = payload.limit || 5
      const format = payload.format || 'pretty' // 'compact', 'pretty', 'minimal'
      
      // –ü–æ–ª—É—á–∞–µ–º –∑–∞–∫–∞–∑—ã
      const { data: jobs, error } = await supabase
        .from('jobs')
        .select('*')
        .eq('status', 'OPEN')
        .eq('is_active', true)
        .order('is_pinned', { ascending: false })
        .order('is_urgent', { ascending: false })
        .order('created_at', { ascending: false })
        .limit(limit)
      
      if (error || !jobs?.length) {
        return new Response(JSON.stringify({ error: 'No jobs found' }), { status: 404 })
      }
      
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–π–¥–∂–µ—Å—Ç
      const result = await sendDigest(jobs, format)
      
      // –õ–æ–≥–∏—Ä—É–µ–º
      for (const job of jobs) {
        await logPost(job.id, result.ok, result)
      }
      
      return new Response(JSON.stringify({ 
        success: result.ok, 
        posted_count: jobs.length,
        format: format,
        jobs: jobs.map(j => ({ id: j.id, title: j.title }))
      }), {
        headers: { 'Content-Type': 'application/json' }
      })
    }
    
    // ========================================
    // 4. –í–´–ë–û–†–û–ß–ù–´–ô –î–ê–ô–î–ñ–ï–°–¢ (–ø–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º ID)
    // ========================================
    if (action === 'post_selected') {
      const jobIds = payload.job_ids // –º–∞—Å—Å–∏–≤ ID: [47, 45, 42]
      const format = payload.format || 'pretty'
      
      if (!jobIds || !Array.isArray(jobIds) || jobIds.length === 0) {
        return new Response(JSON.stringify({ 
          error: 'job_ids array is required',
          example: { action: 'post_selected', job_ids: [47, 45, 42], format: 'pretty' }
        }), { status: 400 })
      }
      
      console.log(`Fetching selected jobs: ${jobIds.join(', ')}`)
      
      // –ü–æ–ª—É—á–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–µ –∑–∞–∫–∞–∑—ã
      const { data: jobs, error } = await supabase
        .from('jobs')
        .select('*')
        .in('id', jobIds)
        .eq('status', 'OPEN')
        .eq('is_active', true)
      
      if (error) {
        console.error('Database error:', error)
        return new Response(JSON.stringify({ error: 'Database error', details: error }), { status: 500 })
      }
      
      if (!jobs || jobs.length === 0) {
        return new Response(JSON.stringify({ 
          error: 'No active jobs found with these IDs',
          requested_ids: jobIds
        }), { status: 404 })
      }
      
      // –°–æ—Ä—Ç–∏—Ä—É–µ–º –≤ —Ç–æ–º –∂–µ –ø–æ—Ä—è–¥–∫–µ, –∫–∞–∫ —É–∫–∞–∑–∞–Ω—ã ID
      const sortedJobs = jobIds
        .map(id => jobs.find(j => j.id == id))
        .filter(Boolean) as Job[]
      
      console.log(`Found ${sortedJobs.length} jobs, sending digest...`)
      
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–π–¥–∂–µ—Å—Ç
      const result = await sendDigest(sortedJobs, format)
      
      // –õ–æ–≥–∏—Ä—É–µ–º
      for (const job of sortedJobs) {
        await logPost(job.id, result.ok, result)
      }
      
      return new Response(JSON.stringify({ 
        success: result.ok, 
        posted_count: sortedJobs.length,
        format: format,
        requested_ids: jobIds,
        found_ids: sortedJobs.map(j => j.id),
        jobs: sortedJobs.map(j => ({ id: j.id, title: j.title }))
      }), {
        headers: { 'Content-Type': 'application/json' }
      })
    }
    
    // ========================================
    // 5. –ü–£–ë–õ–ò–ö–ê–¶–ò–Ø SCHEDULED –ó–ê–ö–ê–ó–û–í (–¥–ª—è cron)
    // ========================================
    if (action === 'publish_scheduled') {
      const now = new Date().toISOString()
      
      console.log(`Checking scheduled jobs at ${now}`)
      
      // –ù–∞—Ö–æ–¥–∏–º –∑–∞–∫–∞–∑—ã —Å PENDING —Å—Ç–∞—Ç—É—Å–æ–º –∏ scheduled_at <= now
      const { data: jobs, error } = await supabase
        .from('jobs')
        .select('*')
        .eq('status', 'PENDING')
        .not('scheduled_at', 'is', null)
        .lte('scheduled_at', now)
      
      if (error) {
        console.error('Error fetching scheduled jobs:', error)
        return new Response(JSON.stringify({ error: error.message }), { status: 500 })
      }
      
      if (!jobs || jobs.length === 0) {
        console.log('No scheduled jobs to publish')
        return new Response(JSON.stringify({ message: 'No scheduled jobs to publish', checked_at: now }), {
          headers: { 'Content-Type': 'application/json' }
        })
      }
      
      console.log(`Found ${jobs.length} scheduled jobs to publish`)
      
      const results = []
      for (const job of jobs) {
        // –ú–µ–Ω—è–µ–º —Å—Ç–∞—Ç—É—Å –Ω–∞ OPEN
        const { error: updateError } = await supabase
          .from('jobs')
          .update({ status: 'OPEN' })
          .eq('id', job.id)
        
        if (updateError) {
          console.error(`Failed to update job ${job.id}:`, updateError)
          results.push({ id: job.id, success: false, error: updateError.message })
          continue
        }
        
        // –ü—É–±–ª–∏–∫—É–µ–º –≤ –∫–∞–Ω–∞–ª
        const result = await sendSingleJob(job)
        await logPost(job.id, result.ok, result)
        
        console.log(`Published job ${job.id}: ${result.ok ? 'success' : 'failed'}`)
        results.push({ id: job.id, title: job.title, success: result.ok })
      }
      
      return new Response(JSON.stringify({ 
        success: true, 
        checked_at: now,
        published: results.filter(r => r.success).length,
        total: jobs.length,
        results 
      }), {
        headers: { 'Content-Type': 'application/json' }
      })
    }
    
    return new Response(JSON.stringify({ message: 'No action taken' }), {
      headers: { 'Content-Type': 'application/json' }
    })
    
  } catch (error) {
    console.error('Error:', error)
    return new Response(JSON.stringify({ error: error.message }), { 
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    })
  }
})
